var documenterSearchIndex = {"docs":
[{"location":"api/#Main-API:","page":"API Docstrings","title":"Main API:","text":"","category":"section"},{"location":"api/#Adaptions-for-custom-types:","page":"API Docstrings","title":"Adaptions for custom types:","text":"","category":"section"},{"location":"api/#Utility","page":"API Docstrings","title":"Utility","text":"","category":"section"},{"location":"api/#Info","page":"API Docstrings","title":"Info","text":"","category":"section"},{"location":"api/#Dangerous-tools","page":"API Docstrings","title":"Dangerous tools","text":"","category":"section"},{"location":"api/#FieldViews.FieldViewable","page":"API Docstrings","title":"FieldViews.FieldViewable","text":"FieldViewable(array::AbstractArray{T,N}) :: FieldViewable{T,N,Store}\n\nWrap an array to enable zero-copy field access via properties.\n\nFieldViewable provides a view-like interface for accessing individual fields of  structs stored in an array, without copying data. Field access returns FieldView objects that can be indexed and modified in-place, with changes reflected in the original array.\n\nExamples\n\nstruct Point{T}\n    x::T\n    y::T\n    z::T\nend\n\npoints = [Point(1.0, 2.0, 3.0), Point(4.0, 5.0, 6.0)]\nfv = FieldViewable(points)\n\n# Access field views\nfv.x  # Returns FieldView{:x, Float64, ...}\nfv.x[1]  # Returns 1.0\n\n# Modify in-place (modifies original array)\nfv.x[1] = 10.0\npoints[1].x  # Now 10.0\n\n# Take views\nslice = view(fv, 1:1)\nslice.y[1] = 99.0\npoints[1].y  # Now 99.0\n\nPerformance Note:\n\nGetting and setting to FieldView vectors is most efficient when the following are satisfied:\n\nThe underlying vector (e.g. arr) satisfies the IsStrided trait\nThe eltype of the array (e.g. Data{Int}) is concrete and inline-allocated\nThe type of the field (e.g. value::Int) is an isbitstype.\n\nWhen all three of the above are satisfied, FieldViews can use efficient pointer methods to get and set fields in the array directly, otherwise we must use a slower fallback that loads the entire struct, modify it, and then sets the entire struct back into the array.\n\nSee also\n\nFieldView: The view type returned by field property access\nfieldmap: Customize field layout for nested structures\n\n\n\n\n\n","category":"type"},{"location":"api/#FieldViews.FieldView","page":"API Docstrings","title":"FieldViews.FieldView","text":"FieldView{field}(parent::AbstractArray)\n\nA view of a specific field across all elements in an array.\n\nFieldView provides element-wise access to a single field of the structs in the parent array. For isbits fields and strided array containers, it uses efficient pointer methods for direct field access. For non-isbits fields, or non-strided arrays it uses a slower fallback which loads the full struct and extracts the  field value.\n\nUsers typically obtain FieldView objects through property access on FieldViewable:\n\nfv = FieldViewable(points)\nx_view = fv.x  # Returns a FieldView{:x, ...}\n\nIndexing\n\nFieldView supports standard array indexing operations:\n\nfv.x[i] - Get field value at index i\nfv.x[i] = val - Set field value at index i (modifies parent array)\n\nExamples\n\nstruct Data{T}\n    value::T\n    weight::Float64\nend\n\narr = [Data(1, 0.5), Data(2, 1.5)]\nfv = FieldViewable(arr)\n\n# Access field view\nvalues = fv.value  # FieldView{:value, Int64, ...}\nvalues[1]  # 1\n\n# Modify through view\nfv.weight[2] = 2.0\narr[2].weight  # 2.0\n\nPerformance Note:\n\nGetting and setting to FieldView vectors is most efficient when the following are satisfied:\n\nThe underlying vector (e.g. arr) satisfies the IsStrided trait\nThe eltype of the array (e.g. Data{Int}) is concrete and inline-allocated (i.e. not backed by a pointer)\nThe type of the field (e.g. value::Int) is an isbitstype.\n\nWhen all three of the above are satisfied, FieldViews can use efficient pointer methods to get and set fields in the array directly, otherwise we must use a slower fallback that loads the entire struct, modify it, and then sets the entire struct back into the array.\n\nSee also\n\nFieldViewable: The view type returned by field property access\nfieldmap: Customize field layout for nested structures\n\n\n\n\n\n","category":"type"},{"location":"api/#FieldViews.fieldmap","page":"API Docstrings","title":"FieldViews.fieldmap","text":"fieldmap(::Type{T}) :: Tuple\n\nDefine the field layout for type T to be used by FieldViews.\n\nAdd methods to this function to customize how FieldViews accesses fields in your types. This is essential for:\n\nFlattening nested structures\nRenaming fields\nExposing only certain fields\n\nDefault Behavior\n\nBy default, returns fieldnames(T), exposing all fields with their original names.\n\nReturn Value\n\nA tuple where each element is one of:\n\nSymbol or Int: Direct field access\nPair{Symbol,Symbol}: Nested field (e.g., :outer => :inner)\nPair{Symbol,Renamed}: Nested field with rename\nRenamed: Renamed direct field\n\nExamples\n\nFlattening nested structures\n\nstruct MyType{T}\n    x::T\n    rest::@NamedTuple{a::Int, b::Int}\nend\n\nfunction FieldViews.fieldmap(::Type{MyType{T}}) where T\n    (:x, :rest => :a, :rest => :b)\nend\n\nfv = FieldViewable([MyType(1.0, (a=1, b=2))])\nfv.a[1]  # Access nested field directly, returns 1\n\nRenaming fields\n\nstruct Foo\n    data::@NamedTuple{_internal::Int}\nend\n\nfunction FieldViews.fieldmap(::Type{Foo})\n    (:data => Renamed(:_internal, :public),)\nend\n\nfv = FieldViewable([Foo((_internal=42,))])\nfv.public[1]  # Returns 42\n\nSee also\n\nRenamed: For field aliasing\nmappedfieldschema: The processed schema generated from fieldmap\n\n\n\n\n\n","category":"function"},{"location":"api/#FieldViews.Renamed","page":"API Docstrings","title":"FieldViews.Renamed","text":"Renamed(actual::Union{Int,Symbol}, alias::Symbol)\n\nSpecify a field rename in custom field mappings.\n\nUsed within fieldmap definitions to expose an internal field under a different  name. This is useful when you want to expose a given field using a different name, or access Tuple fields (since their fields are just integers).\n\nArguments\n\nactual: The real field name or field index in the struct\nalias: The name to expose in the FieldViewable interface\n\nExamples\n\nstruct Foo\n    data::@NamedTuple{_x::Int, _y::Int}\nend\n\nfunction FieldViews.fieldmap(::Type{Foo})\n    (:data => Renamed(:_x, :x), :data => Renamed(:_y, :y))\nend\n\nfv = FieldViewable([Foo((_x=1, _y=2))])\nfv.x[1]  # Access via alias 'x', returns 1\n\nSee also\n\nfieldmap: Define custom field layouts using Renamed\n\n\n\n\n\n","category":"type"},{"location":"api/#FieldViews.StridedArrayTrait","page":"API Docstrings","title":"FieldViews.StridedArrayTrait","text":"StridedArrayTrait(::Type{T}) :: StridedArrayTrait\nStridedArrayTrait(x) :: StridedArrayTrait\n\nQuery or define whether an array type has strided memory layout.\n\nReturns IsStrided() if the array has constant stride offsets in memory, or Unknown() otherwise. Arrays which support IsStrided() auotmatically get more efficient getindex/setindex! implementations for their isbits fields.\n\nIsStrided arrays must support pointer(v, i) methods, and linear indexing.\n\nDefault Behavior\n\nStridedArray types return IsStrided()\nOther AbstractArray types return Unknown()\n\nExtending Support\n\nTo opt into the strided interface for a custom array type: \n\nFieldViews.StridedArrayTrait(::Type{<:MyArrayType}) = FieldViews.IsStrided()\n\nExamples\n\nStridedArrayTrait(Vector{Int})  # IsStrided()\nStridedArrayTrait(view([1,2,3,4], 1:2:4))  # IsStrided()\nStridedArrayTrait(view([1,2,3,4], [1,3,4]))  # Unknown() - non-contiguous indices\n\nA strided array is one where elements are stored at fixed offsets from each other in memory. For example, [1, 2, 3, 4] is strided, as is view(v, 1:2:4) (every other element), but view(v, [1, 3, 4]) is not strided (arbitrary indices).\n\nSee also\n\nIsStrided: Trait for strided arrays\nUnknown: Trait for non-strided arrays\n\n\n\n\n\n","category":"type"},{"location":"api/#FieldViews.IsStrided","page":"API Docstrings","title":"FieldViews.IsStrided","text":"IsStrided <: StridedArrayTrait\n\nTrait indicating that an array type has strided (constant offset) memory layout.\n\nUsed by FieldViews to dispatch on array types that support efficient field access through pointer arithmetic.\n\nSee also\n\nStridedArrayTrait: The trait function for querying array layout\nUnknown: Trait for non-strided arrays\n\n\n\n\n\n","category":"type"},{"location":"api/#FieldViews.Unknown","page":"API Docstrings","title":"FieldViews.Unknown","text":"Unknown <: StridedArrayTrait\n\nTrait indicating that an array type's memory layout is unknown or non-strided.\n\nFor arrays with this trait, FieldViews will fall back on accessing/modifying field elements by loading/storing the entire containing struct, and then using FieldLens!! to manipulate and set the required field. This can be slower in some circumstances.\n\nSee also\n\nStridedArrayTrait: The trait function for querying array layout\nIsStrided: Trait for strided arrays\n\n\n\n\n\n","category":"type"},{"location":"api/#FieldViews.FieldLens!!","page":"API Docstrings","title":"FieldViews.FieldLens!!","text":"FieldLens!!{field}\n\nAn optic for accessing and modifying a specific field of a struct.\n\nFieldLens!! implements the lens interface from Accessors.jl, providing functional field access, immutable or mutable updates. It is primarily used internally by FieldViews for fallback field access/modification, but can also be used directly with the Accessors.jl API.\n\nThe !! in its name is a convention from BangBang.jl which signifies that it will mutate when possible, and perform out-of-place updates when mutation is not possible.\n\nConstructor\n\nFieldLens!!(field::Union{Symbol,Int})\nFieldLens!!{field}()\n\nExamples\n\nstruct Point{T}\n    x::T\n    y::T\nend\n\nlens = FieldLens!!{:x}()\n\np = Point(1, 2)\nlens(p)  # Get: returns 1\n\nusing Accessors\nset(p, lens, 10)  # Set: returns Point(10, 2)\n\nmutable struct MPoint{T}\n    x::T\n    y::T\nend\n\nmp = MPoint(1, 2)\nlens(mp)  # Get: returns 1\n\nset(mp, lens, 10)  # Set: returns Point(10, 2)\nlens(mp)           # Get: returns 10 now since we mutated the object\n\nSee also\n\nAccessors.jl documentation for general lens usage\n\n\n\n\n\n","category":"type"},{"location":"api/#FieldViews.can_use_fast_path","page":"API Docstrings","title":"FieldViews.can_use_fast_path","text":"can_use_fast_path(::Type{<:FieldView}) :: Bool\n\nDetermine whether a FieldView type can use the optimized pointer-based access path.\n\nReturns true if the FieldView can use efficient pointer arithmetic for direct memory access, or false if it must use the potentially slower fallback path that loads and reconstructs entire structs.\n\nFast Path Requirements\n\nThe fast path is used when ALL of the following conditions are met:\n\nStrided storage: The underlying array satisfies StridedArrayTrait(Store) == IsStrided()\nConcrete element type: The element type of the underlying storage is concrete\nInline allocated element type: The element type of the underlying storage is not a pointer-backed type (i.e. Base.allocatedinline)\nIsbits field: The field being accessed is and isbitstype\n\nWhen all conditions are met, FieldViews can compute the exact memory address of each field and read/write directly using unsafe_load/unsafe_store!.\n\nSlow-Path Fallback\n\nWhen any condition is not met, FieldViews uses a fallback that:\n\nFor immutable types: loads the struct, extracts/modifies the field, constructs a new struct\nFor mutable types: loads the struct, uses setfield! to modify in place\n\nThis is called \"slow\" only relative to pointer arithmeticâ€”it still performs comparably to manual struct manipulation.\n\nEven when can_use_fast_path returns false, FieldViews still provides correct and reasonably efficient access. The fast path is an optimization, not a requirement for correctness.\n\nSee Also\n\nStridedArrayTrait: Query whether an array has strided memory layout\nIsStrided: Trait for strided arrays\nFieldView: The view type this function analyzes\n\n\n\n\n\n","category":"function"},{"location":"api/#FieldViews.mappedfieldschema","page":"API Docstrings","title":"FieldViews.mappedfieldschema","text":"mappedfieldschema(::Type{T}) -> NamedTuple\n\nCompute the complete field schema for type T, computed using its fieldmap.\n\nReturns a NamedTuple mapping field names (after renaming) to schema information containing:\n\nlens: An optic for accessing the field\noffset: Byte offset of the field in memory (for isbits fields)\ntype: The field's data type\n\nThis function processes the output of fieldmap to generate the internal schema used by FieldViews for efficient field access.\n\nExamples\n\nstruct Point{T}\n    x::T\n    y::T\n    z::T\nend\n\nschema = FieldViews.mappedfieldschema(Point{Float64})\n# Returns: (x = (lens=..., offset=0, type=Float64),\n#           y = (lens=..., offset=8, type=Float64),\n#           z = (lens=..., offset=16, type=Float64))\n\nschema.x.offset  # 0\nschema.y.offset  # 8\nschema.z.type    # Float64\n\nImplementation Note\n\nThis is typically called internally by FieldViews and rarely needs to be called directly by users. Adding methods to mappedfieldschema incorrectly could cause undefined behaviour.\n\nSee also\n\nfieldmap: The user-facing API for defining field layouts\n\n\n\n\n\n","category":"function"},{"location":"custom_layouts/#Custom-Data-Layouts","page":"-","title":"Custom Data Layouts","text":"","category":"section"},{"location":"custom_layouts/#Working-with-nested-data-layouts","page":"-","title":"Working with nested data-layouts","text":"Sometimes you have nested data but want to treat it as a flattened struct, e.g. adapting an example from the StructArrays.jl docs\n\nstruct MyType{T, NT<:NamedTuple}\n    x::T\n    rest::NT\nend\nMyType(x; kwargs...) = MyType(x, values(kwargs))\n\nfunction Base.getproperty(s::MyType, prop::Symbol)\n    if prop == :x\n        getfield(s, prop)\n    else\n        getfield(getfield(s, :rest), prop)\n    end\nend\nBase.propertynames(s::MyType) = (:data, propertynames(getfield(x, :rest))) \n\njulia> mt = MyType(1.0; a=1, b=2)\nMyType{Float64, @NamedTuple{a::Int64, b::Int64}}(1.0, (a = 1, b = 2))\n\njulia> mt.a\n1\n\njulia> mt.b\n2\n\nWe can support this 'flattened' structure in FieldViews by defining a custom method on fieldmap that tells FieldViews how to traverse the nested fields.\n\nTo teach FieldViews how to handle MyType, we'd do\n\nfunction FieldViews.fieldmap(::Type{MyType{T, NamedTuple{rest_names, rest_types}}}) where {T, rest_names, rest_types}\n\t(:x, map(name -> :rest => name, rest_names)...)\nend\n\njulia> FieldViews.fieldmap(typeof(mt))\n(:x, :rest => :a, :rest => :b)\n\nThis says that there is one field :x which is not redirected, and two inner fields :a and :b which are redirected from :rest. Now our nested struct is compatible with FieldViews.jl\n\njulia> s = FieldViewable([MyType(i/5, a=6-i, b=2) for i in 1:5])\n5-element FieldViewable{MyType{Float64, @NamedTuple{a::Int64, b::Int64}}, 1, Vector{MyType{Float64, @NamedTuple{a::Int64, b::Int64}}}}:\n MyType{Float64, @NamedTuple{a::Int64, b::Int64}}(0.2, (a = 5, b = 2))\n MyType{Float64, @NamedTuple{a::Int64, b::Int64}}(0.4, (a = 4, b = 2))\n MyType{Float64, @NamedTuple{a::Int64, b::Int64}}(0.6, (a = 3, b = 2))\n MyType{Float64, @NamedTuple{a::Int64, b::Int64}}(0.8, (a = 2, b = 2))\n MyType{Float64, @NamedTuple{a::Int64, b::Int64}}(1.0, (a = 1, b = 2))\n\njulia> s.x[1]\n0.2\n\njulia> s.a[2]\n4\n\njulia> s.b[3]\n2","category":"section"},{"location":"custom_layouts/#Renaming-fields","page":"-","title":"Renaming fields","text":"In addition to flattening out nested field structures, FieldViews.jl is also able to support \"renamed\" fields, e.g. \n\nstruct Foo\n    a::Int\n\tdata::@NamedTuple{_b::Int, _c::Int}\nend\n\nfunction FieldViews.fieldmap(::Type{Foo})\n    (:a, :data => Renamed(:_b, :b), :data => Renamed(:_c, :c))\nend\n\njulia> v = FieldViewable([Foo(1, (_b=1, _c=2))]);\n\njulia> v.c\n1-element FieldView{:c, Int64, 1, Foo, Vector{Foo}}:\n 2\n\nThis is used for e.g. StaticArray support to rename Tuple fields to :x, :y, :z, :w.","category":"section"},{"location":"#FieldViews.jl","page":"FieldViews.jl","title":"FieldViews.jl","text":"A FieldViewable is an array that wraps a StridedArray without copying and allows one to access and manipulate views of selected fields of the structs stored in the underlying data. FieldViews.jl provides an API similar to StructArrays.jl, but without copying and with an array-of-structs memory layout instead of a struct-of-array memory layout.\n\nusing FieldViews\n\n# Define a struct type\nstruct Point{T}\n    x::T\n    y::T\n    z::T\nend\n\n# Create an array of Points\npoints = [Point(1.0, 2.0, 3.0), Point(4.0, 5.0, 6.0), Point(7.0, 8.0, 9.0)]\n\njulia> points_fv = FieldViewable(points)\n3-element FieldViewable{Point{Float64}, 1, Vector{Point{Float64}}}:\n Point{Float64}(10.0, 2.0, 3.0)\n Point{Float64}(4.0, 5.0, 6.0)\n Point{Float64}(7.0, 8.0, 9.0)\n\njulia> points_fv.x\n3-element FieldView{:x, Float64, 1, Point{Float64}, Vector{Point{Float64}}}:\n 10.0\n  4.0\n  7.0\n\njulia> points_fv.y\n3-element FieldView{:y, Float64, 1, Point{Float64}, Vector{Point{Float64}}}:\n 2.0\n 5.0\n 8.0\n\njulia> points_fv.x[1]\n10.0\n\njulia> points_fv.y[2]\n5.0\n\njulia> points_fv.x[1] = 10.0 # Modify values in-place\n10.0\n\njulia> points[1].x # original array is modified!\n10.0\n\nInstead of the getproperty syntax, you can directly construct views of particular field using the FieldView{field} constructor:\n\njulia> FieldView{:x}(points)\n3-element FieldView{:x, Float64, 1, Point{Float64}, Vector{Point{Float64}}}:\n 10.0\n  4.0\n  7.0\n\nYou can take views of FieldViews to work with a slice of the array:\n\n# Create a view of a subset\njulia> points_fv_slice = view(points_fv, 2:3)\n2-element FieldViewable{Point{Float64}, 1, SubArray{Point{Float64}, 1, Vector{Point{Float64}}, Tuple{UnitRange{Int64}}, true}}:\n Point{Float64}(4.0, 5.0, 6.0)\n Point{Float64}(7.0, 8.0, 9.0)\n\n# Access fields of the view\njulia> points_fv_slice.x[1] = 99.0\n99.0\n\n# Original array is modified\njulia> points[2]\nPoint{Float64}(99.0, 5.0, 6.0)","category":"section"},{"location":"#Warning:-Fields-versus-Properties","page":"FieldViews.jl","title":"Warning: Fields versus Properties","text":"Be aware that unlike StructArrays.jl, FieldViews.jl operates on the fields of structs, not their properties. Mutating the fields of a struct in an array using FieldViews.jl can therefore violate the API of certain types, and bypass internal constructors, thus creating potentially invalid objects. You should only use FieldViews.jl with arrays of structs you control, or whose field layout is a public part of their API.","category":"section"},{"location":"#Performance-characteristics-of-FieldViews","page":"FieldViews.jl","title":"Performance characteristics of FieldViews","text":"Getting and setting to FieldView arrays is most efficient when the following are satisfied:\n\nThe underlying array (e.g. points) satisfies the IsStrided trait\nThe eltype of the array (e.g. Point{Int}) is concrete and not 'pointer-backed' (i.e. Base.allocatedinline should give true).\nThe type of the field (e.g. x::Int) is concrete and an isbitstype.\n\nWhen all of the above conditions are satisfied, FieldViews can use efficient pointer methods to get and set fields in the array directly without needing to manipulate the entire struct.\n\nIf any of the above conditions is not satisfied, then we need to fetch the entire struct, and then either return the requested field of the struct (getindex), or construct and store a version of the struct where the field has been modified (setindex!).  If the struct is a mutable type, setindex! expressions will call setfield! on the stored struct, otherwise we construct a new version of immutable structs where the requested field is modified (see  Accessors.jl, and our custom FieldLens!! object).\n\nNote that even when the above conditions are not satisfied, the \"slow\" path is only slow relative to regular strided memory views, or something like StructArrays.jl (although note that StructArrays.jl cannot handle non-concrete types). It should still remain just as quick as working directly with the underlying storage array and interacting with whole elements.","category":"section"}]
}
